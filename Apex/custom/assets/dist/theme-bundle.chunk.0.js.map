{"version":3,"sources":["webpack:///./node_modules/nod-validate/nod.js","webpack:///./node_modules/lodash/isNaN.js","webpack:///./node_modules/lodash/_baseGetTag.js","webpack:///./node_modules/lodash/isObjectLike.js","webpack:///./node_modules/lodash/isNumber.js"],"names":["nod","config","configuration","mediator","makeMediator","eventEmitter","makeEventEmitter","listeners","makeCollection","makeListener","checkers","makeChecker","checkHandlers","makeCheckHandler","domNodes","makeDomNode","addMetric","metric","specialTriggers","checkFunction","getCheckFunction","metricSets","getElements","selector","map","element","listener","findOrMake","triggerEvents","checker","checkHandler","domNode","subscribeToTriggers","forEach","subscribeTo","id","validate","toString","push","indexOf","split","metricSet","triggeredBy","checkId","unique","addCheck","errorMessage","defaultStatus","noDom","subscribe","toggleSubmit","addForm","getElement","addEventListener","possiblePreventSubmit","event","preventSubmit","areAll","constants","VALID","preventDefault","performCheck","i","len","length","getStatus","status","INVALID","focus","submit","disableSubmit","submitBtn","disabled","setValid","set","result","options","tap","type","nodInstace","add","metrics","Array","isArray","validateArray","errorMessageArray","errorMsg","Error","remove","removeItem","showErrorMessage","configure","key","value","attributes","k","arguments","form","setMessageOptions","option","parent","errorSpan","setInvalid","setAllNodeValid","uniqueCounter","UNCHECKED","DELAY","classes","successClass","successMessageClass","errorClass","errorMessageClass","subscribers","all","fn","fire","concat","subscribedFunction","findCollectionIndex","collection","maker","index","item","apply","dispose","splice","$element","changed","jQuery","on","eventName","removeEventListener","off","checks","check","callback","undefined","innerHTML","results","hasClass","className","el","classList","contains","regex","RegExp","match","removeClass","replace","addClass","getParent","klass","parentClass","charAt","slice","findParentWithClass","parentNode","_status","pendingUpdate","span","document","createElement","customSpan","updateParent","updateSpan","style","display","successMessage","textContent","delay","clearTimeout","setTimeout","appendChild","parentContainer","message","removeChild","customEvent","emit","CustomEvent","detail","dispatchEvent","get","nodeList","querySelectorAll","call","jquery","nodeType","sel","elements","checkFunctions","regexp","args","fnName","shift","exactValue","containsValue","minimumLength","maximumLength","exactLen","aboveMinLength","belowMaxLength","maximumNumber","minimumNumber","test","sameAsElement","target","reduce","memo","trim","numOfValues","checked","radioElements","reg","RFC822","e","params","evt","bubbles","cancelable","createEvent","initCustomEvent","prototype","window","Event","module","exports","isNumber","nativeObjectToString","Object","baseGetTag","isObjectLike"],"mappings":"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","file":"theme-bundle.chunk.0.js","sourcesContent":["\n/**\n *\n *\n * nod v.2.0.12\n * Gorm Casper\n *\n *\n *\n * This is a short breakdown of the code to help you find your way around.\n *\n *\n * An `element` always refer to some input element defined by the user via the\n * `selector` key.\n *\n * A `metric` is the user created objects that is used to add checks to\n * nod.\n *\n * Each `element` will have at most one of a `listener`, a `checker`, a\n * `checkHandler`, and a `domNode` \"attached\" to it. The `listener` listens\n * for inputs or changes to the `element` and passes the new value on to to the\n * `checker` which performs its checks and passes the the results on to the\n * `checkHandler` which calculates the new state of the `element` which it\n * passes on to the `domNode` which will update the dom.\n *\n * The four main parts, the listener, the checker, the checkHandler, and the\n * domNode all communicate through the `mediator` by firing events identified\n * by a unique id. They do not know of each other's existance, and so no\n * communication flows directly between them.\n *\n * All listeners, checkers, handlers, and domNodes are grouped together in\n * `collections`, which are basically a glorified array that makes it easy\n * not to get duplicate items for each element (for instance two listeners\n * listening to the same element).\n *\n * The communication flow looks like this:\n * listener -> checker -> checkHandler -> domNode\n *\n * Between each part, you have the mediator.\n *\n *\n * `Metrics` are added by the user, which sets up the system above. Notice\n * that a metric can target multiple elements at once, and that there can\n * be overlaps. One metric definitely does not equal one element or one\n * check.\n *\n */\n\nfunction nod (config) {\n    var form,\n        configuration   = {},\n        mediator        = nod.makeMediator(),\n        eventEmitter    = nod.makeEventEmitter(mediator),\n\n        // Creating (empty) collections\n        listeners       = nod.makeCollection(nod.makeListener),\n        checkers        = nod.makeCollection(nod.makeChecker),\n        checkHandlers   = nod.makeCollection(nod.makeCheckHandler),\n        domNodes        = nod.makeCollection(nod.makeDomNode);\n\n    /**\n     * Entry point for the user. The user passes in an array of metrics (an\n     * object containing a selector, a validate string/function, etc.) and it\n     * gets processed from here.\n     *\n     * This function, is mostly about cleaning up what the user passed us.\n     */\n    function addMetrics (metrics) {\n        // Make sure we are dealing with an array of metrics.\n        var arrayMetrics = Array.isArray(metrics) ? metrics : [metrics];\n\n        arrayMetrics.forEach(function (metric) {\n            var validateArray, errorMessageArray,\n                notArray = !Array.isArray(metric.validate);\n\n            // If the 'validate' is not an array, then we're good to go.\n            if (notArray) {\n                addMetric(metric);\n\n            // If it is an array (e.g., validate: ['email', 'max-length:10']),\n            // then we need to split them up into multiple metrics, and add\n            // them individually.\n            } else {\n                if (!Array.isArray(metric.errorMessage)) {\n                    var errorMsg = 'If you pass in `validate:...` as an ' +\n                        ' array, then `errorMessage:...` also needs to be an ' +\n                        ' array. \"' + metric.validate + '\", and \"' +\n                        metric.errorMessage + '\"';\n\n                    throw Error(errorMsg);\n                }\n\n                // We store each as arrays, and then run through them,\n                // overwriting each of the keys accordingly.\n                validateArray     = metric.validate;\n                errorMessageArray = metric.errorMessage;\n\n                validateArray.forEach(function (validate, i) {\n                    // Overwrite the array with the individual 'validate' and\n                    // 'errorMessage'.\n                    metric.validate     = validate;\n                    metric.errorMessage = errorMessageArray[i];\n\n                    addMetric(metric);\n                });\n            }\n        });\n    }\n\n    function addMetric (metric) {\n        var specialTriggers = [],\n\n            // The function that will check the value of the element.\n            checkFunction = nod.getCheckFunction(metric),\n\n            // A list of elements that this metric will target.\n            elements = nod.getElements(metric.selector),\n\n            // A \"set\" here, refers to an obj with one listener, one checker,\n            // and one checkHandler. Only every one for each element in the\n            // dom.\n            metricSets = elements.map(function (element) {\n                return {\n                    listener:       listeners.findOrMake(element,\n                                                         mediator,\n                                                         metric.triggerEvents,\n                                                         configuration),\n                    checker:        checkers.findOrMake(element, mediator),\n                    checkHandler:   checkHandlers.findOrMake(element,\n                                                             mediator,\n                                                             configuration),\n                    domNode:        domNodes.findOrMake(element,\n                                                        mediator,\n                                                        configuration)\n                };\n            });\n\n        // Saved for later reference in case the user has a `tap` function\n        // defined.\n        checkFunction.validate = (typeof metric.validate === 'function')\n            ? metric.validate.toString()\n            : metric.validate;\n\n        // Special cases. These `validates` affect each other, and their state\n        // needs to update each time either of the elements' values change.\n        if (metric.validate === 'one-of'\n            || metric.validate === 'only-one-of'\n            || metric.validate === 'some-radio') {\n            specialTriggers.push(metric.selector);\n        }\n\n        if (typeof metric.validate === 'string'\n            && metric.validate.indexOf('same-as') > -1) {\n            specialTriggers.push(metric.validate.split(':')[1]);\n        }\n\n        // Helper function, used in the loop below.\n        function subscribeToTriggers (checker, selector) {\n            var triggerElements = nod.getElements(selector);\n\n            triggerElements.forEach(function (element) {\n                var listener = listeners.findOrMake(element,\n                                                    mediator,\n                                                    null,\n                                                    configuration);\n\n                checker.subscribeTo(listener.id);\n            });\n        }\n\n        // Here we set up the \"connections\" between each of our main parts.\n        // They communicate only through the mediator.\n        metricSets.forEach(function (metricSet) {\n            // :: Listener -> Checker\n\n            // We want our checker to listen to the listener. A listener has an\n            // id, which it uses when it fires events to the mediator (which\n            // was set up when the listener was created).\n            metricSet.checker.subscribeTo(metricSet.listener.id);\n\n            // If the user set a `triggeredBy`, the checker need to listen to\n            // changes on this element as well.\n            // Same goes for special triggers that we set.\n            subscribeToTriggers(metricSet.checker, metric.triggeredBy);\n            subscribeToTriggers(metricSet.checker, specialTriggers);\n\n            // :: Checker -> checkHandler\n\n            var checkId = nod.unique();\n\n            // We add the check function as one to be checked when the user\n            // inputs something. (There might be more than this one).\n            metricSet.checker.addCheck(checkFunction, checkId);\n\n            // We want the check handler to listen for results from the checker\n            metricSet.checkHandler.subscribeTo(checkId,\n                                               metric.errorMessage,\n                                               metric.defaultStatus);\n\n            if (configuration.noDom) {\n                eventEmitter.subscribe(metricSet.checkHandler.id);\n            } else {\n                // :: checkHandler -> domNode\n\n                // The checkHandler has its own id (and only ever needs one), so\n                // we just ask the domNode to listen for that.\n                metricSet.domNode.subscribeTo(metricSet.checkHandler.id);\n            }\n        });\n\n        // After all is done, we may have to enable/disable a submit button.\n        toggleSubmit();\n    }\n\n    /**\n     * If a form is added, we listen for submits, and if the has also set\n     * `preventSubmit` in the configuration, then we stop the commit from\n     * happening unless all the elements are valid.\n     */\n    function addForm (selector) {\n        var form = nod.getElement(selector);\n\n        form.addEventListener('submit', possiblePreventSubmit, false);\n    }\n\n    // Prevent function, used above\n    function possiblePreventSubmit (event) {\n        if (configuration.preventSubmit && !areAll(nod.constants.VALID)) {\n            event.preventDefault();\n\n            // Show errors to the user\n            checkers.forEach(function (checker) {\n                checker.performCheck({\n                    event: event\n                });\n            });\n\n            // Focus on the first invalid element\n            for (var i = 0, len = checkHandlers.length; i < len; i++) {\n                var checkHandler = checkHandlers[i];\n\n                if (checkHandler.getStatus().status === nod.constants.INVALID) {\n                    checkHandler.element.focus();\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Removes elements completely.\n     */\n    function removeElement (selector) {\n        var elements = nod.getElements(selector);\n\n        elements.forEach(function (element) {\n            listeners.removeItem(element);\n            checkers.removeItem(element);\n            checkHandlers.removeItem(element);\n            domNodes.removeItem(element);\n        });\n    }\n\n    /**\n     * configure\n     *\n     * Changes the configuration object used throughout the code for classes,\n     * delays, messages, etc.\n     *\n     * It can either be called with a key/value pair (two arguments), or with\n     * an object with key/value pairs.\n     */\n    function configure (key, value) {\n        var attributes = {};\n\n        if (arguments.length > 1) {\n            attributes[key] = value;\n        } else {\n            attributes = key;\n        }\n\n        for (var k in attributes) {\n            configuration[k] = attributes[k];\n        }\n\n        if (attributes.submit || attributes.disableSubmit) {\n            toggleSubmit();\n        }\n\n        if (attributes.form) {\n            addForm(attributes.form);\n        }\n    }\n\n    /**\n     * toggleSubmit\n     *\n     * Toggles the submit button (enabled if every element is valid, otherwise\n     * disabled).\n     */\n    function toggleSubmit () {\n        if (configuration.submit && configuration.disableSubmit) {\n            nod.getElements(configuration.submit).forEach(function (submitBtn) {\n                submitBtn.disabled = !areAll(nod.constants.VALID);\n            });\n        }\n    }\n\n    /**\n     * Listen to all checks, and if the user has set in the configuration to\n     * enable/disabled the submit button, we do that.\n     */\n    mediator.subscribe('all', toggleSubmit);\n\n    function areAll (status) {\n        for (var i = 0, len = checkHandlers.length; i < len; i++) {\n            if (checkHandlers[i].getStatus().status !== status) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function setMessageOptions (options) {\n        options = Array.isArray(options) ? options : [options];\n\n        options.forEach(function (option) {\n            var elements = nod.getElements(option.selector);\n\n            elements.forEach(function (element) {\n                var domNode = domNodes.findOrMake(element,\n                                                  mediator,\n                                                  configuration);\n\n                domNode.setMessageOptions(option.parent, option.errorSpan);\n            });\n        });\n    }\n\n    /**\n     * Listen to all checks and allow the user to listen in, if he set a `tap`\n     * function in the configuration.\n     */\n    mediator.subscribe('all', function (options) {\n        if (typeof configuration.tap === 'function'\n            && options.type === 'check') {\n            configuration.tap(options);\n        }\n    });\n\n    function getStatus (selector, showErrorMessage) {\n        var element = nod.getElement(selector),\n            status  = checkHandlers.findOrMake(element).getStatus();\n\n        return showErrorMessage ? status : status.status;\n    }\n\n    function performCheck (selector) {\n        var cs = selector\n            ? nod.getElements(selector).map(checkers.findOrMake)\n            : checkers;\n\n        cs.forEach(function (checker) {\n            checker.performCheck();\n        });\n    }\n\n    function setInvalid (selector, errorMessage) {\n        var element = nod.getElement(selector),\n            domNode  = domNodes.findOrMake(element);\n\n        domNode.set({\n            result: nod.constants.INVALID,\n            errorMessage: errorMessage || ''\n        });\n    }\n\n    function setValid (selector) {\n        var element = nod.getElement(selector),\n            domNode  = domNodes.findOrMake(element);\n\n        domNode.set({\n            result: nod.constants.VALID,\n            errorMessage: ''\n        });\n    }\n\n    function setAllNodeValid () {\n        for (var i = 0, len = domNodes.length; i < len; i++) {\n            setValid(domNodes[i].element);\n        }\n    }\n\n    /**\n     * Internal functions that are exposed to the public.\n     */\n    var nodInstace = {\n        add:                    addMetrics,\n        remove:                 removeElement,\n        areAll:                 areAll,\n        getStatus:              getStatus,\n        configure:              configure,\n        setMessageOptions:      setMessageOptions,\n        performCheck:           performCheck,\n        setInvalid:             setInvalid,\n        setValid:               setValid,\n        setAllNodeValid:        setAllNodeValid\n    };\n\n    if (config) {\n        nodInstace.configure(config);\n    }\n\n    return nodInstace;\n}\n\nnod.constants = {\n    VALID:          'valid',\n    INVALID:        'invalid',\n    UNCHECKED:      'unchecked',\n\n    DELAY:          700\n};\n\nnod.classes = {\n    successClass:         'nod-success',\n    successMessageClass:  'nod-success-message',\n    errorClass:           'nod-error',\n    errorMessageClass:    'nod-error-message'\n};\n\n// Helper function to create unique id's\nnod.unique = (function () {\n    var uniqueCounter = 0;\n\n    return function () {\n        return uniqueCounter++;\n    };\n})();\n\n/** makeMediator\n *\n * Minimal implementation of a mediator pattern, used for communication between\n * checkers and checkHandlers (checkers fires events which handlers can\n * subscribe to). Unique ID's are used to tell events apart.\n *\n * Subscribing to 'all' will give you all results from all checks.\n */\nnod.makeMediator = function () {\n    var subscribers = [],\n        all = [];\n\n    return {\n        subscribe: function subscribe (id, fn) {\n            if (id === 'all') {\n                all.push(fn);\n            } else {\n                if (!subscribers[id]) {\n                    subscribers[id] = [];\n                }\n\n                if (subscribers[id].indexOf(fn) === -1) {\n                    subscribers[id].push(fn);\n                }\n            }\n        },\n\n        fire: function fire (options) {\n            var subscribedFunctions = subscribers[options.id].concat(all);\n\n            subscribedFunctions.forEach(function (subscribedFunction) {\n                subscribedFunction(options);\n            });\n        }\n    };\n};\n\nnod.findCollectionIndex = function (collection, element) {\n    for (var i in collection) {\n        if (collection[i].element === element) {\n            return i;\n        }\n    }\n\n    return -1;\n};\n\n/**\n * makeCollection\n *\n * A minimal implementation of a \"collection\", inspired by collections from\n * BackboneJS. Used by listeners, checkers, and checkHandlers.\n */\nnod.makeCollection = function (maker) {\n    var collection = [];\n\n    collection.findOrMake = function (element) {\n        var index = nod.findCollectionIndex(collection, element);\n\n        // Found\n        if (index !== -1) {\n            return collection[index];\n        }\n\n        // None found, let's make one then.\n        var item = maker.apply(null, arguments);\n\n        collection.push(item);\n\n        return item;\n    };\n\n    collection.removeItem = function (element) {\n        var index = nod.findCollectionIndex(collection, element),\n            item = collection[index];\n\n        if (!item) {\n            return;\n        }\n\n        // Call .dispose() if it exists\n        if (typeof item.dispose === 'function') {\n            item.dispose();\n        }\n\n        // Remove item\n        collection.splice(index, 1);\n    };\n\n    return collection;\n};\n\n/**\n * makeListener\n *\n * Takes care of listening to changes to its element and fire them off as\n * events on the mediator for checkers to listen to.\n */\nnod.makeListener = function (element, mediator, triggerEvents, configuration) {\n    var id = nod.unique(),\n        $element;\n\n    function changed (event) {\n        mediator.fire({\n            id:     id,\n            event:  event,\n            type:   'change'\n        });\n    }\n\n    element.addEventListener('input', changed, false);\n    element.addEventListener('change', changed, false);\n    element.addEventListener('blur', changed, false);\n\n    if (configuration.jQuery) {\n        $element = configuration.jQuery(element);\n\n        $element.on('propertychange change click keyup input paste', changed);\n    }\n\n    if (triggerEvents) {\n        triggerEvents = Array.isArray(triggerEvents)\n            ? triggerEvents\n            : [triggerEvents];\n\n        triggerEvents.forEach(function (eventName) {\n            element.addEventListener(eventName, changed, false);\n        });\n    }\n\n    function dispose () {\n        element.removeEventListener('input', changed, false);\n        element.removeEventListener('change', changed, false);\n        element.removeEventListener('blur', changed, false);\n\n        if ($element) {\n            $element.off();\n        }\n\n        if (triggerEvents) {\n            triggerEvents.forEach(function (eventName) {\n                element.removeEventListener(eventName, changed, false);\n            });\n        }\n    }\n\n    return {\n        element:    element,\n        dispose:    dispose,\n        id:         id\n    };\n};\n\n/**\n * makeChecker\n *\n * An \"checker\" communicates primarily with the mediator. It listens for input\n * changes (coming from listeners), performs its checks and fires off results\n * back to the mediator for checkHandlers to handle.\n *\n * The checker has a 1 to 1 relationship with an element, an listeners, and an\n * checkHandler; although they may communicate with other \"sets\" of listeners,\n * checkers and handlers.\n *\n * Checks are added, from the outside, and consists of a checkFunction (see\n * nod.checkFunctions) and a unique id.\n */\nnod.makeChecker = function (element, mediator) {\n    var checks = [];\n\n    function subscribeTo (id) {\n        mediator.subscribe(id, performCheck);\n    }\n\n    // Run every check function against the value of the element.\n    function performCheck (options) {\n        checks.forEach(function (check) {\n            check(options || {});\n        });\n    }\n\n    // Add a check function to the element. The result will be handed off to the\n    // mediator (for checkHandlers to evaluate).\n    function addCheck (checkFunction, id) {\n        function callback (result) {\n            mediator.fire({\n                id: id,\n                type: 'check',\n                result: result,\n                element: element,\n                validate: checkFunction.validate\n            });\n        }\n\n        checks.push(function (options) {\n            // If element.value is undefined, then we might be dealing with\n            // another type of element; like <div contenteditable='true'>\n            var value = element.value === undefined\n                ? element.innerHTML\n                : element.value;\n\n            options.element = element;\n\n            checkFunction(callback, value, options);\n        });\n    }\n\n    return {\n        subscribeTo:    subscribeTo,\n        addCheck:       addCheck,\n        performCheck:   performCheck,\n        element:        element\n    };\n};\n\n/**\n * makeCheckHandler\n *\n * Handles checks coming in from the mediator and takes care of calculating the\n * state and error messages.\n *\n * The checkHandlers lives in one to one with the element parsed in, and listens\n * for (usually) multiple error checks.\n */\nnod.makeCheckHandler = function (element, mediator, configuration) {\n    var results     = {},\n        id          = nod.unique();\n\n    function subscribeTo (id, errorMessage, defaultStatus) {\n        // Create a representation of the type of error in the results object.\n        if (!results[id]) {\n            results[id] = {\n                status: defaultStatus || nod.constants.UNCHECKED,\n                errorMessage: errorMessage\n            };\n        }\n\n        // Subscribe to error id.\n        mediator.subscribe(id, checkHandler);\n    }\n\n    function checkHandler (result) {\n        results[result.id].status = result.result\n            ? nod.constants.VALID\n            : nod.constants.INVALID;\n\n        notifyMediator();\n    }\n\n    // Runs through all results to see what kind of feedback to show the user.\n    function notifyMediator () {\n        var status = getStatus();\n\n        // Event if might be valid we pass along an undefined errorMessage.\n        mediator.fire({\n            id:             id,\n            type:           'result',\n            result:         status.status,\n            element:        element,\n            errorMessage:   status.errorMessage\n        });\n    }\n\n    function getStatus () {\n        var status, errorMessage;\n\n        for (var id in results) {\n            status = results[id].status;\n\n            if (results[id].status === nod.constants.INVALID) {\n                errorMessage = results[id].errorMessage;\n                break;\n            }\n        }\n\n        return {\n            status:        status,\n            errorMessage:  errorMessage\n        };\n    }\n\n    return {\n        id:             id,\n        subscribeTo:    subscribeTo,\n        checkHandler:   checkHandler,\n        getStatus:      getStatus,\n        element:        element\n    };\n};\n\n// Helper functions for `makeDomNode`.\nnod.hasClass = function (className, el) {\n    if (el.classList) {\n        return el.classList.contains(className);\n    } else {\n        var regex = new RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\n        return !!el.className.match(regex);\n    }\n};\n\nnod.removeClass = function (className, el) {\n    if (el.classList) {\n        el.classList.remove(className);\n    } else if (nod.hasClass(className, el)) {\n        var regex = new RegExp('(?:^|\\\\s)' + className + '(?!\\\\S)');\n        el.className = el.className.replace(regex, '');\n    }\n};\n\nnod.addClass = function (className, el) {\n    if (el.classList) {\n        el.classList.add(className);\n    } else if (!nod.hasClass(className, el)) {\n        el.className += ' ' + className;\n    }\n};\n\nnod.getParent = function (element, configuration) {\n    var klass = configuration.parentClass;\n\n    if (klass) {\n        klass = klass.charAt(0) === '.' ? klass.slice(1) : klass;\n        return nod.findParentWithClass(element.parentNode, klass);\n    } else {\n        return element.parentNode;\n    }\n};\n\nnod.findParentWithClass = function (parent, klass) {\n    // Guard (only the `window` does not have a parent).\n    if (!parent.parentNode) {\n        return parent;\n    }\n\n    // Found it\n    if (nod.hasClass(klass, parent)) {\n        return parent;\n    }\n\n    // Try next parent (recursion)\n    return nod.findParentWithClass(parent.parentNode, klass);\n};\n\n/**\n * makeDomNode\n *\n * This creates the error/success message behind the input element, as well as\n * takes care of updating classes and taking care of its own state.\n *\n * The dom node is owned by checkHandler, and has a one to one relationship with\n * both the checkHandler and the input element being checked.\n *\n */\nnod.makeDomNode = function (element, mediator, configuration) {\n    // A 'domNode' consists of two elements: a 'parent', and a 'span'. The\n    // parent is given as a paremeter, while the span is created and added as a\n    // child to the parent.\n    var parent              = nod.getParent(element, configuration),\n        _status             = nod.constants.UNCHECKED,\n        pendingUpdate       = null,\n        span                = document.createElement('span'),\n        customSpan          = false;\n\n    span.style.display = 'none';\n\n    if (!configuration.noDom) {\n        parent.appendChild(span);\n    }\n\n    // Updates the class of the parent to match the status of the element.\n    function updateParent (status) {\n        var successClass = configuration.successClass\n                           || nod.classes.successClass,\n            errorClass = configuration.errorClass\n                         || nod.classes.errorClass;\n\n        switch (status) {\n        case nod.constants.VALID:\n            nod.removeClass(errorClass, parent);\n            nod.addClass(successClass, parent);\n            break;\n\n        case nod.constants.INVALID:\n            nod.removeClass(successClass, parent);\n            nod.addClass(errorClass, parent);\n            break;\n        }\n    }\n\n    // Updates the text and class according to the status.\n    function updateSpan (status, errorMessage) {\n        var successMessageClass = configuration.successMessageClass\n                                  || nod.classes.successMessageClass,\n          errorMessageClass   = configuration.errorMessageClass\n                                || nod.classes.errorMessageClass;\n\n        span.style.display = 'none';\n\n        switch (status) {\n        case nod.constants.VALID:\n            nod.removeClass(errorMessageClass, span);\n            nod.addClass(successMessageClass, span);\n\n            if (configuration.successMessage) {\n                span.textContent = configuration.successMessage;\n                span.style.display = '';\n            }\n\n            break;\n\n        case nod.constants.INVALID:\n            nod.removeClass(successMessageClass, span);\n            nod.addClass(errorMessageClass, span);\n            span.textContent = errorMessage;\n            span.style.display = '';\n            break;\n        }\n    }\n\n    function set (options) {\n        var status              = options.result,\n            errorMessage        = options.errorMessage;\n\n        // If the dom is showing an invalid message, we want to update the dom\n        // right away.\n        if (_status === nod.constants.INVALID || configuration.delay === 0) {\n            _status = status;\n            updateParent(status);\n            updateSpan(status, errorMessage);\n        } else {\n            // If the dom shows either an unchecked or a valid state we won't\n            // rush to tell them they are wrong. Instead we use a method similar\n            // to \"debouncing\" the update\n            clearTimeout(pendingUpdate);\n\n            pendingUpdate = setTimeout(function () {\n                _status = status;\n                updateParent(status);\n                updateSpan(status, errorMessage);\n                pendingUpdate = null;\n            }, configuration.delay || nod.constants.DELAY);\n        }\n    }\n\n    function subscribeTo (id) {\n        mediator.subscribe(id, set);\n    }\n\n    function setMessageOptions (parentContainer, message) {\n        if (parentContainer) {\n            parent = nod.getElement(parentContainer);\n        }\n\n        if (message) {\n            span.parentNode.removeChild(span);      // Remove old span.\n            span = nod.getElement(message);         // Set the new one.\n            customSpan = true;                      // So we won't delete it.\n        }\n    }\n\n    function dispose () {\n        // First remove any classes\n        nod.removeClass(configuration.errorClass\n                        || nod.classes.errorClass, parent);\n        nod.removeClass(configuration.successClass\n                        || nod.classes.successClass, parent);\n\n        // Then we remove the span if it wasn't one that was set by the user.\n        // If `noDom` was used, then there won't be any to remove.\n        if (span.parentNode && !customSpan) {\n            span.parentNode.removeChild(span);\n        }\n    }\n\n    return {\n        subscribeTo:        subscribeTo,\n        element:            element,\n        setMessageOptions:  setMessageOptions,\n        dispose:            dispose,\n        set:                set\n    };\n};\n\nnod.makeEventEmitter = function (mediator) {\n    var customEvent;\n\n    function emit (options) {\n        if (CustomEvent) {\n            customEvent = new CustomEvent('nod.validation', {detail: options});\n\n            options.element.dispatchEvent(customEvent);\n        } else {\n            var errorMsg = 'nod.validate tried to fire a custom event, but ' +\n                           'the browser does not support CustomEvent\\'s';\n\n            throw Error(errorMsg);\n        }\n    }\n\n    function subscribe (id) {\n        mediator.subscribe(id, emit);\n    }\n\n    return {\n        subscribe: subscribe\n    };\n};\n\n/**\n * getElement\n *\n * Returns the first element targeted by the selector. (see `getElements`)\n */\nnod.getElement = function (selector) {\n    return nod.getElements(selector)[0];\n};\n\n/**\n * getElements\n *\n * Takes some sort of selector, and returns an array of element(s). The applied\n * selector can be one of:\n *\n * - Css type selector (e.g., \".foo\")\n * - A jQuery element (e.g., $('.foo))\n * - A single raw dom element (e.g., document.getElementById('foo'))\n * - A list of raw dom element (e.g., $('.foo').get())\n */\nnod.getElements = function (selector) {\n    if (!selector) {\n        return [];\n    }\n\n    // Normal css type selector is assumed\n    if (typeof selector === 'string') {\n        // If we have jQuery, then we use that to create a dom list for us.\n        if (window.jQuery) {\n            return window.jQuery(selector).get();\n        }\n\n        // If not, then we do it the manual way.\n        var nodeList = document.querySelectorAll(selector);\n\n        return [].map.call(nodeList, function (el) {\n            return el;\n        });\n    }\n\n    // if user gave us jQuery elements\n    if (selector.jquery) {\n        return selector.get();\n    }\n\n    // Raw DOM element\n    if (selector.nodeType === 1) {\n        return [selector];\n    }\n\n    if (Array.isArray(selector)) {\n        var result = [];\n\n        selector.forEach(function (sel) {\n            var elements = nod.getElements(sel);\n\n            result = result.concat(elements);\n        });\n\n        return result;\n    }\n\n    throw Error('Unknown type of elements in your `selector`: ' + selector);\n};\n\nnod.getCheckFunction = function (metric) {\n    if (typeof metric.validate === 'function') {\n        return metric.validate;\n    }\n\n    if (metric.validate instanceof RegExp) {\n        return nod.checkFunctions.regexp(metric.validate);\n    }\n\n    var args   = metric.validate.split(':'),\n        fnName = args.shift();\n\n    if (fnName === 'one-of' || fnName === 'only-one-of' ||\n        fnName === 'same-as' || fnName === 'some-radio') {\n        args.push(metric.selector);\n    }\n\n    if (typeof nod.checkFunctions[fnName] === 'function') {\n        return nod.checkFunctions[fnName].apply(null, args);\n    } else {\n        var errorMsg = 'Couldn\\'t find your validator function \"' +\n                       fnName + '\" for \"' + metric.selector + '\"';\n\n        throw Error(errorMsg);\n    }\n};\n\n// Collection of built-in check functions\nnod.checkFunctions = {\n    'presence': function () {\n        return function presence (callback, value) {\n            callback(value.length > 0);\n        };\n    },\n\n    'exact': function (exactValue) {\n        return function exact (callback, value) {\n            callback(value === exactValue);\n        };\n    },\n\n    'contains': function (containsValue) {\n        return function contains (callback, value) {\n            callback(value.indexOf(containsValue) > -1);\n        };\n    },\n\n    'not': function (exactValue) {\n        return function not (callback, value) {\n            callback(value !== exactValue);\n        };\n    },\n\n    'min-length': function (minimumLength) {\n        return function minLength (callback, value) {\n            callback(value.length >= minimumLength);\n        };\n    },\n\n    'max-length': function (maximumLength) {\n        return function maxLength (callback, value) {\n            callback(value.length <= maximumLength);\n        };\n    },\n\n    'exact-length': function (exactLen) {\n        return function exactLength (callback, value) {\n            callback(value.length === +exactLen);\n        };\n    },\n\n    'between-length': function (minimumLength, maximumLength) {\n        return function betweenLength (callback, value) {\n            var aboveMinLength = value.length >= minimumLength,\n                belowMaxLength = value.length <= maximumLength;\n\n            callback(aboveMinLength && belowMaxLength);\n        };\n    },\n\n    'max-number': function (maximumNumber) {\n        return function maxNumber (callback, value) {\n            callback(+value <= maximumNumber);\n        };\n    },\n\n    'min-number': function (minimumNumber) {\n        return function minNumber (callback, value) {\n            callback(+value >= minimumNumber);\n        };\n    },\n\n    'between-number': function (minimumNumber, maximumNumber) {\n        return function betweenNumber (callback, value) {\n            callback(+value >= minimumNumber && +value <= maximumNumber);\n        };\n    },\n\n    'integer': function () {\n        return function (callback, value) {\n            callback(/^\\s*\\d+\\s*$/.test(value));\n        };\n    },\n\n    'float': function () {\n        return function (callback, value) {\n            callback(/^[-+]?[0-9]+(\\.[0-9]+)?$/.test(value));\n        };\n    },\n\n    'same-as': function (selector) {\n        var sameAsElement = nod.getElement(selector);\n\n        return function sameAs (callback, value, options) {\n            // 'same-as' is special, in that if it is triggered by another field\n            // (the one it should be similar to), and the field itself is empty,\n            // then it bails out without a check. This is to avoid showing an\n            // error message before the user has even reached the element.\n            if (options &&\n                options.event &&\n                options.event.target &&\n                options.event.target !== options.element &&\n                value.length === 0) {\n                return;\n            }\n\n            callback(value === sameAsElement.value);\n        };\n    },\n\n    'one-of': function (selector) {\n        var elements = nod.getElements(selector);\n\n        function getValues () {\n            return elements.reduce(function (memo, element) {\n                return memo + '' + (element.value || '');\n            }, '');\n        }\n\n        return function oneOf (callback) {\n            callback(getValues().trim().length > 0);\n        };\n    },\n\n    'only-one-of': function (selector) {\n        var elements = nod.getElements(selector);\n\n        return function onlyOneOf (callback, value) {\n            var numOfValues = 0;\n\n            elements.forEach(function (element) {\n                if (element.value) {\n                    numOfValues++;\n                }\n            });\n\n            callback(numOfValues === 1);\n        };\n    },\n\n    'checked': function () {\n        return function checked (callback, value, options) {\n            callback(options.element.checked);\n        };\n    },\n\n    'some-radio': function (selector) {\n        var radioElements = nod.getElements(selector);\n\n        return function someRadio (callback, value, options) {\n            var result = radioElements.reduce(function (memo, element) {\n                return memo || element.checked;\n            }, false);\n\n            callback(result);\n        };\n    },\n\n    'regexp': function (reg) {\n        return function regExp (callback, value) {\n            callback(reg.test(value));\n        };\n    },\n\n    'email': function () {\n        var RFC822 = /^([^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+|\\x22([^\\x0d\\x22\\x5c\\x80-\\xff]|\\x5c[\\x00-\\x7f])*\\x22)(\\x2e([^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+|\\x22([^\\x0d\\x22\\x5c\\x80-\\xff]|\\x5c[\\x00-\\x7f])*\\x22))*\\x40([^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+|\\x5b([^\\x0d\\x5b-\\x5d\\x80-\\xff]|\\x5c[\\x00-\\x7f])*\\x5d)(\\x2e([^\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2e\\x3a-\\x3c\\x3e\\x40\\x5b-\\x5d\\x7f-\\xff]+|\\x5b([^\\x0d\\x5b-\\x5d\\x80-\\xff]|\\x5c[\\x00-\\x7f])*\\x5d))*$/;\n\n        return function email (callback, value) {\n            callback(RFC822.test(value));\n        };\n    }\n};\n\n// CustomEvent polyfill for older IE versions. Taken from\n// github.com/d4tocchini/customevent-polyfill/blob/master/CustomEvent.js\ntry {\n    new CustomEvent(\"test\");\n} catch (e) {\n    var CustomEvent = function (event, params) {\n        var evt;\n        params = params || {\n            bubbles: false,\n            cancelable: false,\n            detail: undefined\n        };\n\n        evt = document.createEvent(\"CustomEvent\");\n        evt.initCustomEvent(event,\n                            params.bubbles,\n                            params.cancelable,\n                            params.detail);\n        return evt;\n    };\n\n    CustomEvent.prototype = window.Event.prototype;\n    window.CustomEvent = CustomEvent;\n}\n\n// Safely export nod.\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = nod;\n}\n","var isNumber = require('./isNumber');\n\n/**\n * Checks if `value` is `NaN`.\n *\n * **Note:** This method is based on\n * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\n * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n * `undefined` and other non-number values.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n * @example\n *\n * _.isNaN(NaN);\n * // => true\n *\n * _.isNaN(new Number(NaN));\n * // => true\n *\n * isNaN(undefined);\n * // => true\n *\n * _.isNaN(undefined);\n * // => false\n */\nfunction isNaN(value) {\n  // An `NaN` primitive is the only value that is not equal to itself.\n  // Perform the `toStringTag` check first to avoid errors with some\n  // ActiveX objects in IE.\n  return isNumber(value) && value != +value;\n}\n\nmodule.exports = isNaN;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar numberTag = '[object Number]';\n\n/**\n * Checks if `value` is classified as a `Number` primitive or object.\n *\n * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n * classified as numbers, use the `_.isFinite` method.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n * @example\n *\n * _.isNumber(3);\n * // => true\n *\n * _.isNumber(Number.MIN_VALUE);\n * // => true\n *\n * _.isNumber(Infinity);\n * // => true\n *\n * _.isNumber('3');\n * // => false\n */\nfunction isNumber(value) {\n  return typeof value == 'number' ||\n    (isObjectLike(value) && baseGetTag(value) == numberTag);\n}\n\nmodule.exports = isNumber;\n"],"sourceRoot":""}